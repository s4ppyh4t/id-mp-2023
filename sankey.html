<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="Data Visualisation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Test Sankey Chart</title>        
        <link rel="stylesheet" href="style/sankey.css">
        <link rel="stylesheet" href="style/general.css">
        <link rel="stylesheet" href="style/nav.css">
        <script src="https://d3js.org/d3.v7.min.js"></script>    
        <!-- <script src="eight_two.js"></script> -->
        <!-- <script src="script/data_inject.js"></script> -->
        
        <!-- importing sankey plugin from Mike Bostock - ObservableHQ -->
        <script src="plugins/d3-sankey.min.js"></script>    
        <script src="plugins/text-wrap.js"></script>
        
    </head>
    <body>
        <header id="top">
            <h1>DATA VISUALISATION PROJECT - TEAM 11</h1>
            <!-- <h2></h2> -->
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="spider.html#viz">Internal Displacement</a></li>
                    <li><a class="on-page" href="sankey.html#sankey-here">Australia PR Migration</a></li>
                </ul>
            </nav>
            <br>
            <h2>Australian Permanent Resident Migration Data</h1>
            <p class="caption">Data period: 2000 - 8/2021</p>
        </header>
        <body>
        <div id="sankey-here"></div>

        <script>
            data = d3.csv('test2.csv').then((data) => {
                // console.log(data);
                // console.log(data.length);
                const dimensions = Object({ height: 500, width: 900, margins: 20 });

                let sankeyData = { nodes: [], links: [] };
                
                // map out and generate a node list of distinct sources and targets
                let sourceList = data.map((d) => d.source);
                let targetList = data.map((d) => d.target);

                fullList = Array.from(new Set([...sourceList,...targetList]));
                
                let nameList = fullList.map((d) => {return {name: d}});
                
                // push data to sankeyData "nodes" array
                sankeyData.nodes.push(...nameList); // DONE

                // push each links to the sankeyData "links" array
                data.forEach((d) => {
                    // ========================CODE FROM TUTORIAL===============================
                    // // Here the code map out the list of nodes in sankeyData object
                    // // ... into an array of just nodes ( e.g. return ["name1", "name2", "name3"]
                    // // ... from { nodes: [{name: "name1"}, {name: "name2"},...], links....} )
                    // const listOfNodes = sankeyData.nodes.map((n) => n.name);

                    // // this list of nodes will then be brought out to
                    // // cross-check, whether this list has the name of
                    
                    // // the source... 
                    // if (!listOfNodes.includes(d.source)) {
                    //     sankeyData.nodes.push({name: d.source});
                    // }

                    // // .. or the target's names. This basically generates an unique list of
                    // // .. source and target names into sankeyData's "nodes"
                    // if (!listOfNodes.includes(d.target)) {
                    //     sankeyData.nodes.push({name: d.target});
                    // }
                    
                    // ============= I might do something else actually, check code above ==========
                    
                    // The code eventually pushes link objects to sankeyData
                    
                    console.log();

                    // since we need the index reference as source and targets for "links" array anyway, how about 
                    // ... I do that here eheheheheh phunny moment
                    let sourceIndex = sankeyData.nodes.findIndex( (i) => i.name === d.source );    
                    let targetIndex = sankeyData.nodes.findIndex( (i) => i.name === d.target );   

                    sankeyData.links.push({
                        source: sourceIndex,
                        target: targetIndex,
                        value: d.value
                    });
                }); //DONE
                   
                // Generate the d3.sankey generator cosntructor
                const sankeyViz = d3
                        .sankey()
                        .nodes(sankeyData.nodes)
                        .links(sankeyData.links)
                        .nodeAlign(d3.sankeyLeft)
                        .nodeWidth(175)
                        .extent([
                        [dimensions.margins, dimensions.margins],
                        [
                        dimensions.width - dimensions.margins * 2,
                        dimensions.height - dimensions.margins * 2
                        ]
                        ]);
            
                // call and assign sankyfied data to "sankeyData" variable
                sankeyData = sankeyViz();   // DONE

                // This will fix the invisible gradient later down the line hehehe
                sankeyData.links.forEach( (d) => {
                    if (d.y0 === d.y1) { d.y1 += 0.001;}
                } )
                sankeyData.nodes.forEach( (d) => {
                    d.nodeWidth = d.x1 - d.x0;
                })
                // console.log(sankeyData); //CHECK FOR VALIDATION

                // ============================================================================
                // Now we got the sankeyfied data, let's start drawing shits hehehehe ahahahahh
                // =============================================================================
 

                // I'm gonna STEAL their color scale... yoink
                // tehcnically not stealing but "eh"
                colorScale = d3
                        .scaleOrdinal()
                        .domain(sankeyData.nodes.map((n) => n.name))
                        .range(["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#ff33cc", "#9933ff"])
                
                const svg = d3.select("#sankey-here")
                    .append("svg")
                    .attr("height", dimensions.height)
                    .attr("width", dimensions.width)
                    .attr("overflow", "visible");

                const chart = svg
                    .append("g")
                    .attr("transform", `translate(${dimensions.margins},${dimensions.margins})`)
                    .attr("height", dimensions.height - dimensions.margins * 2)
                    .attr("width", dimensions.width - dimensions.margins * 2)
                    .attr("overflow", "visible");

                const adjustor = (i) => {
                    if (i === 8) {
                    return 5;
                    } else if (i === 6) {
                    return -5;
                    } else return 0;
                };

                chart.append("text")
                    .text("UH BRUH THIS IS AMAZING HEEH")
                    .attr("dominant-baseline", "middle")
                    .attr("font-size", "2vh")
                    .attr("font-weight", "600");


                // ===================================================
                // =============== THE NODES =========================
                // ===================================================

                const nodes = chart.append("g")
                    .attr("id", "node-group")
                    .selectAll("rect")
                    .data(sankeyData.nodes)
                    .enter()
                    .append("rect")
                    .attr("class", "node")
                    .attr("x", (d) => d.x0)
                    .attr("y", (d) => d.y0)
                    .attr("fill", (d) => colorScale(d.name))
                    .attr("height", (d) => d.y1 - d.y0)
                    .attr("width", (d) => d.x1 - d.x0);
                
                // ===================================================
                // =============== THE LINKS =========================
                // ===================================================
                
                // The linearGradient elements to define gradient colors for the links
                svg.append("defs")
                    .selectAll("linearGradient")
                    .data(sankeyData.links)
                    .enter()
                    .append("linearGradient")
                    .attr("id", d => `${d.source.index}-link-${d.target.index}`)
                    // .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", "0%")
                    .attr("x2", "100%")
                    .call(gradient => gradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", ({source: {name: i}}) => {return colorScale(i);}))
                    .call(gradient => gradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", ({target: {name: i}}) => {return colorScale(i);}));
                
                const links = chart
                    .append("g")
                    .attr("fill", "none")
                    .attr("stroke-opacity", 0.4)
                    .selectAll("path")
                    .data(sankeyData.links)
                    .join("path")
                    .attr("stroke", (d) => {
                        // console.log( `url("#${d.source.index}-link-${d.target.index}")`);
                        return `url(#${d.source.index}-link-${d.target.index})`;
                        // return "gray";
                    })
                    .attr("class", "linkage")
                    .attr("d", d3.sankeyLinkHorizontal())
                    .attr("stroke-width", function (d) {
                        return d.width;
                    });


                // ===================================================
                // ===================================================
                
                
                // Node name labelling heheheeh
                const labelNames = chart.append("g")
                    .selectAll("text")
                    .data(sankeyData.nodes)
                    .enter()
                    .append("text")
                    .text((d) => d.name + " " + d3.format("~s")(d.value))
                    .attr("class", (d) => `${d.depth} node-label`)
                    .attr("x", (d) => d3.mean([d.x0, d.x1]))
                    .attr("y", (d) => d3.mean([d.y0, d.y1]))
                    .attr("dy", (d) => `${-5 + adjustor(d.index)}px`)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .attr("fill", (d) => (d.y1 - d.y0 < 20 ? "black" : "white"))
                    .attr("font-family", "monospace")
                    .attr("font-weight", "bold")
                    .attr("font-size", "2vh")
                    .style("mix-blend-mode", "normal")
                    .attr("value", (d) => d.nodeWidth)
                    // .style("text-shadow", ".5px .5px 2px #222")
                    .style("opacity", (d) => (d.y1 - d.y0 < 20 ? 0 : 1))
                    // WRAPPING ==============================================
                    .call(wrap);
                

                // const labelValues = chart
                //     .append("g")
                //     .selectAll("text")
                //     .data(sankeyData.nodes)
                //     .join("text")
                //     .text((d) => `${d3.format("~s")(d.value)}`)
                //     .attr("x", (d) => d3.mean([d.x0, d.x1]))
                //     .attr("y", (d) => d3.mean([d.y0, d.y1]))
                //     .attr("dy", (d) => `${15 + adjustor(d.index)}px`)
                //     .attr("text-anchor", "middle")
                //     .attr("dominant-baseline", "middle")
                //     .attr("fill", (d) => (d.y1 - d.y0 < 20 ? "black" : "white"))
                //     .attr("font-family", "monospace")
                //     .attr("font-weight", "200")
                //     .attr("font-size", "2vh")
                //     .style("text-shadow", ".5px .5px 2px #222")
                //     .style("opacity", (d) => (d.y1 - d.y0 < 40 ? 0 : 1));

                console.log(d3.selectAll(".node"));
                

                // ===============================================================================
                // ========================Hovering Time for nodes================================
                // ===============================================================================
                d3.selectAll('.node').on("mouseover", (event, d) => {
                    let selLinks = d3.selectAll(".linkage").filter((link) => {
                        
                        // console.log(d);
                        return (link.source.index === d.index) || (link.target.index === d.index);
                    })
                    // console.log(selLinks);

                    .transition()
                    .duration(50)
                    // .ease(d3.easeLinear)
                    .attr('stroke-opacity', '0.9');
                })

                nodes.on("mouseout", () => {
                    d3.selectAll(".linkage")
                    .transition()
                    .duration(50)
                    // .ease(d3.easeLinear)
                    .attr('stroke-opacity', '0.4')
                })

                // ===============================================================================
                // =====================For the links (to previous links)=========================
                // ===============================================================================
                links.on("mouseover", (event, d) => {
                    let prevSelLinks = d3.selectAll(".linkage").filter((link) => {
                        
                    })
                })


                

            });     // End tag of the WHOLE DATA INJECTION STUFF PLZ REMEMBER HOLY SHIT <========================
            



        </script>



        </body>

        <footer>
            <p class="caption boldnice">COS30045 Data Vis - Final Project</p>
            <p class="caption">Semester 1 2023</p>
        </footer>
    </body>
</html>